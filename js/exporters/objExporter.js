/**
 * OBJ 导出器模块
 * 将体素网格导出为 Wavefront OBJ 格式
 */

const ObjExporter = {
    /**
     * 导出体素网格为 OBJ 格式
     * @param {Object} voxelGrid 体素网格数据
     * @param {Object} options 导出选项
     * @returns {Object} 包含 obj 和 mtl 文件内容
     */
    export(voxelGrid, options = {}) {
        const {
            filename = 'voxel_model',
            blockSize = 1,
            optimizeFaces = true
        } = options;

        const { voxels, bounds } = voxelGrid;
        const voxelMap = Voxelizer.createVoxelMap(voxels);

        // 收集材质
        const materials = new Map();
        for (const voxel of voxels) {
            const colorKey = voxel.block.color.join(',');
            if (!materials.has(colorKey)) {
                materials.set(colorKey, {
                    name: this.sanitizeName(voxel.block.name),
                    color: voxel.block.color
                });
            }
        }

        // 生成 MTL 文件
        const mtlContent = this.generateMTL(materials, filename);

        // 生成 OBJ 文件
        const objContent = this.generateOBJ(voxels, voxelMap, materials, {
            filename,
            blockSize,
            optimizeFaces,
            bounds
        });

        return {
            obj: objContent,
            mtl: mtlContent,
            filename
        };
    },

    /**
     * 生成 MTL 材质文件
     * @param {Map} materials 材质映射
     * @param {string} filename 文件名
     * @returns {string} MTL 文件内容
     */
    generateMTL(materials, filename) {
        let content = `# Voxel Art Converter - Material Library\n`;
        content += `# Generated by Voxel Art Converter\n\n`;

        for (const [colorKey, mat] of materials) {
            const [r, g, b] = mat.color;
            const rf = (r / 255).toFixed(6);
            const gf = (g / 255).toFixed(6);
            const bf = (b / 255).toFixed(6);

            content += `newmtl ${mat.name}\n`;
            content += `Ka 0.2 0.2 0.2\n`;           // 环境光颜色
            content += `Kd ${rf} ${gf} ${bf}\n`;     // 漫反射颜色
            content += `Ks 0.1 0.1 0.1\n`;           // 高光颜色
            content += `Ns 10.0\n`;                   // 高光指数
            content += `illum 2\n`;                   // 光照模型
            content += `\n`;
        }

        return content;
    },

    /**
     * 生成 OBJ 文件
     * @param {Array} voxels 体素数组
     * @param {Map} voxelMap 体素映射
     * @param {Map} materials 材质映射
     * @param {Object} options 选项
     * @returns {string} OBJ 文件内容
     */
    generateOBJ(voxels, voxelMap, materials, options) {
        const { filename, blockSize, optimizeFaces, bounds } = options;

        let content = `# Voxel Art Converter - 3D Model\n`;
        content += `# Voxels: ${voxels.length}\n`;
        content += `# Size: ${bounds.sizeX} x ${bounds.sizeY} x ${bounds.sizeZ}\n`;
        content += `mtllib ${filename}.mtl\n\n`;

        // 中心偏移
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const centerY = (bounds.minY + bounds.maxY) / 2;
        const centerZ = (bounds.minZ + bounds.maxZ) / 2;

        const vertices = [];
        const normals = [
            [1, 0, 0],   // +X (right)
            [-1, 0, 0],  // -X (left)
            [0, 1, 0],   // +Y (top)
            [0, -1, 0],  // -Y (bottom)
            [0, 0, 1],   // +Z (front)
            [0, 0, -1]   // -Z (back)
        ];

        // 按材质分组的面
        const facesByMaterial = new Map();
        for (const mat of materials.values()) {
            facesByMaterial.set(mat.name, []);
        }

        const halfSize = blockSize / 2;
        let vertexCount = 0;

        // 为每个体素生成面
        for (const voxel of voxels) {
            const x = (voxel.x - centerX) * blockSize;
            const y = (voxel.y - centerY) * blockSize;
            const z = (voxel.z - centerZ) * blockSize;

            const colorKey = voxel.block.color.join(',');
            const matName = materials.get(colorKey).name;

            // 检查每个面的可见性
            const faces = optimizeFaces
                ? Voxelizer.getVisibleFaces(voxelMap, voxel)
                : { right: true, left: true, top: true, bottom: true, front: true, back: true };

            // 8 个顶点
            const v = [
                [x - halfSize, y - halfSize, z - halfSize], // 0: ---
                [x + halfSize, y - halfSize, z - halfSize], // 1: +--
                [x + halfSize, y + halfSize, z - halfSize], // 2: ++-
                [x - halfSize, y + halfSize, z - halfSize], // 3: -+-
                [x - halfSize, y - halfSize, z + halfSize], // 4: --+
                [x + halfSize, y - halfSize, z + halfSize], // 5: +-+
                [x + halfSize, y + halfSize, z + halfSize], // 6: +++
                [x - halfSize, y + halfSize, z + halfSize]  // 7: -++
            ];

            // 添加可见面
            const faceList = facesByMaterial.get(matName);

            if (faces.right) {  // +X
                faceList.push({
                    verts: [v[1], v[5], v[6], v[2]],
                    normal: 1
                });
            }
            if (faces.left) {   // -X
                faceList.push({
                    verts: [v[4], v[0], v[3], v[7]],
                    normal: 2
                });
            }
            if (faces.top) {    // +Y
                faceList.push({
                    verts: [v[3], v[2], v[6], v[7]],
                    normal: 3
                });
            }
            if (faces.bottom) { // -Y
                faceList.push({
                    verts: [v[0], v[4], v[5], v[1]],
                    normal: 4
                });
            }
            if (faces.front) {  // +Z
                faceList.push({
                    verts: [v[4], v[7], v[6], v[5]],
                    normal: 5
                });
            }
            if (faces.back) {   // -Z
                faceList.push({
                    verts: [v[0], v[1], v[2], v[3]],
                    normal: 6
                });
            }
        }

        // 写入顶点
        const vertexMap = new Map();
        let vertexIndex = 1;

        for (const faceList of facesByMaterial.values()) {
            for (const face of faceList) {
                for (const vert of face.verts) {
                    const key = vert.join(',');
                    if (!vertexMap.has(key)) {
                        vertexMap.set(key, vertexIndex++);
                        vertices.push(vert);
                    }
                }
            }
        }

        // 写入顶点数据
        content += `# Vertices: ${vertices.length}\n`;
        for (const v of vertices) {
            content += `v ${v[0].toFixed(4)} ${v[1].toFixed(4)} ${v[2].toFixed(4)}\n`;
        }
        content += `\n`;

        // 写入法线
        content += `# Normals\n`;
        for (const n of normals) {
            content += `vn ${n[0]} ${n[1]} ${n[2]}\n`;
        }
        content += `\n`;

        // 写入面 (按材质分组)
        for (const [matName, faceList] of facesByMaterial) {
            if (faceList.length === 0) continue;

            content += `usemtl ${matName}\n`;
            content += `s off\n`;

            for (const face of faceList) {
                const indices = face.verts.map(v => vertexMap.get(v.join(',')));
                content += `f ${indices[0]}//${face.normal} ${indices[1]}//${face.normal} ${indices[2]}//${face.normal} ${indices[3]}//${face.normal}\n`;
            }
            content += `\n`;
        }

        return content;
    },

    /**
     * 清理材质名称 (移除特殊字符)
     * @param {string} name 
     * @returns {string}
     */
    sanitizeName(name) {
        return name.replace(/[^a-zA-Z0-9_]/g, '_');
    },

    /**
     * 下载导出的文件
     * @param {Object} exportData 导出数据
     */
    download(exportData) {
        const { obj, mtl, filename } = exportData;

        // 下载 OBJ 文件
        this.downloadFile(`${filename}.obj`, obj, 'model/obj');

        // 下载 MTL 文件
        this.downloadFile(`${filename}.mtl`, mtl, 'text/plain');
    },

    /**
     * 下载单个文件
     * @param {string} filename 文件名
     * @param {string} content 内容
     * @param {string} mimeType MIME 类型
     */
    downloadFile(filename, content, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
};
